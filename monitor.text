        .TITLE  "MONITOR - SYSTEM ROM-RESIDENT MONITOR AND BIOS"
        .ABSOLUTE
        .PROC   MONITOR

	.INCLUDE  BIOS_CFG.TEXT

        .ORG    0000H


;
;  "Z2" WAS THE LAST MONITOR VERSION BUILT IN THE 1980'S.
;  I BELIEVE THAT I BUMPED THE LETTER PART OF THE VERSION CODE WHEN A
;  CHANGE WAS MADE THAT WAS INCOMPATIBLE WITH OTHER PARTS OF THE SOFTWARE.
;  I DON'T REMEMBER WHY I JUMPED TO "Z" IN THE 1980'S, NOR WHAT THE
;  LAST LETTER THAT I'D USED BEFORE THAT WAS.  SO I'LL START THE
;  2015 VERSION OF MONITOR WITH "M".
;

VERSION  .EQU  "M3"

;       MODIFICATIONS:
;
;  01 JAN 16 - DELETE DEAD CODE SO THAT EVERYTHING FITS
;  21 DEC 15 - USE BIOS_CFG.TEXT FOR SYMBOLS SHARED BETWEEN PROM 0 AND PROM 1 (M2).
;  26 NOV 15 - ADD SUPPORT FOR IDE DISK CONTROLLER (M1).
;  04 FEB 85 - ADDED ASSEMBLY OPTION TO MAKE MONITOR WORK WITH DDT IN PROM.
;  05 JAN 85 - CHANGED MEMORY CONFIGURATION TO USE ALL OF TOP MEMORY (K3).
;  29 DEC 84 - ADDED USER INTERRUPT ENTRY POINT (K2).
;
;
;
;


        .INCLUDE *ASMINC.TEXT
        .INCLUDE DUTEXT.TEXT

        DEF_MPU                 DEFINE MPU SYMBOLS
        DEF_CH                  DEFINE CHARACTER SYMBOLS


        .PAGE
;*        MONITOR COMMAND OPTIONS
;
;  WHEN THE MONITOR COMMAND ROUTINE IS ENTERED
;  DUE TO A PROCESSOR RESET OR DDT M COMMAND,
;  IT FIRST CHECKS THE CPU OPTION SWITCH.  IF THIS
;  SWITCH IS SET AND DISK UNIT ZERO IS READY, THE
;  MONITOR BOOTS FROM THAT UNIT.  OTHERWISE, THE
;  MONITOR PROMPTS THE OPERATOR AND WAITS FOR A
;  BOOT UNIT NUMBER.
;



;*        BOOTSTRAP ENTRY CONDITIONS
;
;  B REGISTER CONTAINS THE NUMBER OF THE DISK UNIT
;         FROM WHICH THE BOOTSTRAP WAS READ.
;
;  C REGISTER CONTAINS THE ENTRY CODE:
;
;         0 - FAST BOOTSTRAP (MONITOR F COMMAND)
;         1 - STANDARD BOOTSTRAP (MONITOR B COMMAND)
;         FF - PATCHING MODE (MONITOR P COMMAND)
;
;  HL REGISTER CONTAINS THE ADDRESS OF THE HIGHEST
;  MEMORY LOCATION THAT IS AVAILABLE.
;
;  SP REGISTER EQUAL TO HL.
;



;*        MONITOR REQUESTS
;
;  MONITOR REQUESTS ARE MADE VIA A RST 40 INSTRUCTION.  ALTERNATELY,
;  THE REQUEST MAY BE MADE WITH A CALL INSTRUCTION
;  DIRECTLY TO ENTRY POINT REQUEST IN MONITOR.
;
;  THE REQUEST NUMBER (SEE BELOW) IS PASSED IN
;  REGISTER A.  REGISTERS B, C, D, E, H, L AND IY
;  ARE AVAILABLE FOR PASSING PARAMETERS TO
;  MONITOR, AND ALL REGISTERS ARE AVAILABLE
;  FOR MONITOR TO PASS RESPONSES BACK TO THE
;  CALLER.
;
        .PAGE


;*        TEMPORARY DEFINITIONS
;
;
CH_VS   .EQU    1FH             ; UNTIL CORRECTED IN Z80TEXT
P_MS    .EQU    0               ; PROCESSOR STATUS
CH_HOME .EQU    CH_EM           ; HOME CURSOR
CH_EEOS .EQU    CH_VT           ; ERASE TO END OF SCREEN
CH_0    .EQU    "0"             ; ZERO CHARACTER
CH_A    .EQU    "A"             ; THE CHARACTER A
CH_Z    .EQU    "Z"
CH_UL   .EQU    "_"
CH_AT   .EQU    "@"

;*        INTERNAL SYMBOL DEFINITIONS
;
;
IVECTOR .EQU    0100H           ; INTERRUPT VECTOR ADDRESS
MSTKSIZE .EQU    44.             ; MAX SIZE OF MONITOR STACK
TRPEND  .EQU    3               ; OFFSET FROM ORIGIN OF DDT ENTRY
TRPCODE .EQU    55H             ; VALUE OF FIRST BYTE OF DDT
L_DSKRB .EQU    11.             ; LENGTH OF DISK REQUEST BLOCK



;*        MONITOR USER STATE CODES
;
;  THESE CODES RECORD THE WAY THAT THE MONITOR WAS LAST ENTERED.
;
USTRST0 .EQU    0               ; RST INSTRUCTION OR JUMP TO 0000
USTRESET .EQU    1               ; USER STATE CODE FOR PROCESSOR RESET
USTNMI  .EQU    2               ; USER STATE CODE FOR NMI ENTRY
USTDONE .EQU    3               ; USER PROGRAM IS DONE
USTHOST .EQU    4               ; HOST INTERRUPT
USTDMT  .EQU    5               ; DEADMAN TIMER INTERRUPT
USTMCE  .EQU    6               ; MONITOR CALL ERROR
USTGO   .EQU    7               ; USER PROCESS NOW RUNABLE
USTRST8 .EQU    08H             ; RST INSTRUCTION TO 0#0008
USTRST16 .EQU    10H             ; RST INSTRUCTION TO 0#0010
USTRST24 .EQU    18H             ; RST INSTRUCTION TO 0#0018
USTRST32 .EQU    20H             ; RST INSTRUCTION TO 0#0020
USTRST40 .EQU    28H             ; RST INSTRUCTION TO 0#0028
USTRST48 .EQU    30H             ; RST INSTRUCTION TO 0#0030
USTRST56 .EQU    38H             ; RST INSTRUCTION TO 0#0038
USTLEV0 .EQU    40H             ; UNEXPECTED INTERRUPT LEVEL 0
USTLEV1 .EQU    41H             ; UNEXPECTED INTERRUPT LEVEL 1
USTLEV2 .EQU    42H             ; UNEXPECTED INTERRUPT LEVEL 2
USTLEV3 .EQU    43H             ; UNEXPECTED INTERRUPT LEVEL 3
USTLEV4 .EQU    44H             ; UNEXPECTED INTERRUPT LEVEL 4
USTLEV5 .EQU    45H             ; UNEXPECTED INTERRUPT LEVEL 5
USTLEV6 .EQU    46H             ; UNEXPECTED INTERRUPT LEVEL 6
USTLEV7 .EQU    47H             ; UNEXPECTED INTERRUPT LEVEL 7



;*        MONITOR WORK SPACE
;
;
USERPC  .EQU    MONWORK         ; STORAGE FOR USER PC
USERAF  .EQU    MONWORK+2       ; USER AF
USERBC  .EQU    MONWORK+4       ; USER BC
USERDE  .EQU    MONWORK+6       ; USER DE
USERHL  .EQU    MONWORK+8       ; USER HL
USERIX  .EQU    MONWORK+0AH     ; USER IX
USERIY  .EQU    MONWORK+0CH     ; USER IY
USERSP  .EQU    MONWORK+0EH     ; USER STACK POINTER
USERI   .EQU    MONWORK+10H     ; USER I REGISTER
USERN   .EQU    MONWORK+11H     ; USER INTERRUPT ENABLE
USERAFAL .EQU    MONWORK+12H     ; ALTERNATE USER AF
USERBCAL .EQU    MONWORK+14H     ; ALTERNATE USER BC
USERDEAL .EQU    MONWORK+16H     ; ALTERNATE USER DE
USERHLAL .EQU    MONWORK+18H     ; ALTERNATE USER HL
USTCODE .EQU    MONWORK+1AH     ; MONITOR USER STATE CODE
TRAPADR .EQU    MONWORK+1BH     ; ADDRESS OF USER TRAP HANDLER
;                  MONWORK+01CH    SECOND BYTE OF ABOVE
DISPWORK .EQU    MONWORK+1DH     ; WORK AREA FOR DISPDRV
SCCWORK .EQU    DISPWORK+6      ; WORK AREA FOR SERIAL COMM. CONTROLLER
DSKWORK .EQU    SCCWORK+41.     ; WORK AREA FOR DISKDRV
MONSTACK .EQU   DSKWORK+0        ; LIMIT OF MONITOR STACK
MSTKBASE .EQU   MONSTACK+MSTKSIZE ; BASE OF MONITOR STACK

        .IF     ~DDTMON
SERWORKB .EQU    WORKB           ; WORK AREA FOR SERIAL DRIVER
        .ENDC

        .PAGE
;*        MACRO GOTOXY - POSITION DISPLAY CURSOR
;
;  THIS MACRO GENERATES A STRING OF CHARACTER BYTES,
;  WHICH, WHEN INTERPRETED BY THE DISPLAY DRIVER,
;  WILL POSITION THE CURSOR TO A GIVEN LINE AND
;  COLUMN POSITION.
;
;  CALL - THE SECOND PARAMETER GIVES THE VERTICAL LOCATION.
;         THE FIRST PARAMETER GIVES THE HORIZONTAL LOCATION.
;
        .MACRO  GOTOXY
        .BYTE   CH_RS
        .BYTE   CH_A+%1
        .BYTE   CH_A+%2
        .ENDM



;*        MACRO LINE - GENERATE CHARACTERS TERMINATED BY <CR><LF>
;
;
        .MACRO  LINE
        .ASCII  "%1"
        .BYTE   CH_CR
        .BYTE   CH_LF
        .ENDM



        .PAGE
;*
;
;  JUMP TO THE APPROPRIATE MONITOR ENTRY ROUTINE.
;

        .ORG    P_RESET
        ASSUME  P_RESET,EQ,P.RST0
        LD      (USERAF),A      ; SAVE A REGISTER
        JP      MONLOC0         ; GO PROCESS ENTRY AT LOCATION ZERO

        .ORG    P_RST8
        PUSH    AF              ; SAVE A AND FLAGS
        LD      A,USTRST8       ; REMEMBER WHERE WE CAME FROM
        JP      DOTRAP

        .ORG    P_RST16
        PUSH    AF
        LD      A,USTRST16
        JP      DOTRAP

        .ORG    P_RST24
        PUSH    AF
        LD      A,USTRST24
        JP      DOTRAP

        .ORG    P_RST32
        PUSH    AF
        LD      A,USTRST32
        JP      DOTRAP

        .ORG    P_RST40
        JP      REQUEST

        .ORG    P_RST48
        PUSH    AF
        LD      A,USTRST48
        JP      DOTRAP

        .ORG    P_RST56
        PUSH    AF
        LD      A,USTRST56
        JP      DOTRAP
        .PAGE
;*        MONLOC0 - PROCESS ENTRY THROUGH LOCATION ZERO
;
;  THE PROCESSOR CAN ENTER LOCATION ZERO THREE WAYS%
;
;         1.  JUMP TO LOCATION ZERO
;         2.  PROCESSOR RESET
;         3.  RST 0 INSTRUCTION
;
;  THIS CODE SEPARATES PROCESSOR RESETS FROM THE
;  OTHER TWO BY EXAMINING THE I REGISTER.  IF IT IS ZERO, THE
;  PROCESSOR MUST HAVE BEEN RESET.
;
;         ENTRY - A REGISTER SAVED IN -USERAF-
;                 IF ENTERED VIA RST, USER PC ON TOP OF STACK.
;
MONLOC0
        .IF     INROM

        LD      A,I             ; GET INTERRUPT TABLE POINTER
        CP      0               ; IS IT ZERO
        JR      Z,DORESET       ; YES.  PROCESSOR MUST HAVE BEEN RESET

        .ELSE

        JP      DORESET         ; ALWAYS RESET IN RAM MODE

        .ENDC

;
;  MONITOR WAS ENTERED VIA A RST 0 OR A JUMP TO
;  LOCATION ZERO.  THIS IS HANDLED THE SAME AS
;  OTHER RST ENTRIES, SO SET UP THE ENTRY
;  CONDITIONS OF -DOTRAP-, AND JUMP TO IT.
;
        LD      A,(USERAF)      ; GET BACK USER A REGISTER
        PUSH    AF              ; STORE ON STACK

        LD      A,P_RST0        ; REMEMBER WHERE ENTERED
        JP      DOTRAP          ; GO MERGE WITH OTHER RST-S

;*        REQUEST ENTRY POINT
;
;  MONITOR IS ENTERED HERE WHEN A USER PROGRAM REQUESTS
;  SOME SERVICE.
;
REQUEST
        PUSH    BC              ; SAVE CONTENTS OF BC
        LD      B,0             ; CLEAR TOP OF BC
        LD      C,A             ; MOVE REQUEST NUMBER TO C
        LD      IX,REQTBL       ; ADDRESS OF REQUEST TABLE
        ADD     IX,BC           ; COMPUTE ENTRY ADDRESS
        POP     BC              ; RESTORE BC

        LD      A,(IX+0)        ; GET FIRST BYTE OF ENTRY
        CP      0C3H            ; MUST BE JP OP-CODE
        JR      NZ,BADREQ       ; JUMP IF ILLEGAL REQUEST

        JP      (IX+0)          ; JUMP INTO TABLE ENTRY
        .PAGE
;*      USER INTERRUPT ENTRY POINT
;
;  IF THE KEYBOARD INTERRUPT HANDLER SEES A PARTICULAR KEY COMBINATION,
;  IT SETS UP THE STACK SO THAT THE PROCESSOR COMES HERE AFTER COMPLETION
;  OF THE INTERRUPT.
;
;       ENTRY - USER PC ON TOP OF STACK
;
USERINT
        PUSH    AF              ; SAVE USER AF
        LD      A,USTHOST         ; SET UP ENTRY CODE
        JR      $10             ; GO DO TRAP



;*        NON-MASKABLE INTERRUPT HARDWARE ENTRY POINT
;
;
        .ORG    P_NMI
        PUSH    AF
        LD      A,USTNMI
$10     JP      DOTRAP



;*
;  ILLEGAL MONITOR REQUEST RECEIVED.  TREAT AS A TRAP, EXCEPT THAT
;  THE USER AF AND IX ARE UNAVAILABLE.
;
BADREQ
        PUSH    AF              ; PUSH DUMMY AF
        LD      A,USTMCE        ; ILLEGAL MONITOR REQUEST
        JP      DOTRAP
        .PAGE
;*        REQUEST TABLE
;
;
REQTBL
        .BLOCK  3               ; 0 - RESERVED
        JP      PTRWRT          ; 3 - WRITE TO PRINTER
        JP      DISPCH          ; 6 - DISPLAY CHARACTER
        JP      DISPSTR         ; 9 - DISPLAY STRING
        JP      UDONE           ; C - OS EXIT TO MONITOR
        JP      KEYSTAT         ; F - GET KEYBOARD STATUS
        JP      KEYNECHO        ; 12 - READ KEYBOARD W/O ECHO
        JP      KEYCHAR         ; 15 - READ 1 CHAR FROM KEYBOARD

        .IF     ~DDTMON

        JP      SERSET          ; 18 - SET SERIAL INTERFACE PARAMETERS
        JP      DISPTXT         ; 1B - DISPLAY TEXT
        JP      DSKADR          ; 1E - CONVERT DISK ADDRESS
        JP      READCLK         ; 21 - READ TICK CLOCK
        JP      DSKRD           ; 24 - READ DISK
        JP      DSKWRT          ; 27 - WRITE DISK
        .BLOCK  3               ; 2A - NOT USED (WAS DISK STATUS)
        JP      SERSTAT         ; 2D - GET SERIAL INTERFACE STATUS
        JP      SERREAD         ; 30 - READ CHARACTER FROM SERIAL INTERFACE
        JP      SERWRITE        ; 33 - WRITE CHARACTER TO SERIAL INTERFACE
        JP      OLDCTL          ; 36 - OLD SERIAL CONTROL FUNCTION

        .ENDC

        .PAGE
;*        USER EXIT MONITOR REQUEST
;
;
UDONE
        PUSH    AF              ; SAVE A DUMMY AF VALUE

        LD      A,USTDONE       ; MONITOR ENTRY CODE
        JP      DOTRAP
        .PAGE
;*
;  INITIALIZE THE PROCESSOR AFTER SYSTEM RESET OR
;  POWER-UP.
;
;  SET THE PROCESSOR I REGISTER TO POINT TO THE INTERRUPT VECTOR,
;  AND PUT THE PROCESSOR INTO THE PROPER INTERRUPT MODE.
;
DORESET
        ASSUME  -IVECTOR/100H*100H+IVECTOR,EQ,0 ; LOW BYTE ZERO
        LD      A,IVECTOR/100H   ; POINTER TO INTERRUPT VECTOR
        LD      I,A             ; MOVE TO I REGISTER
        LD      (USERI),A       ; USE SAME IN USER MODE

        IM      2               ; SET  PROPER INTERRUPT MODE

        LD      A,1             ; SET USER INTERRUPT ENABLE
        LD      (USERN),A

        LD      A,V_MIOLV6      ; ENABLE SELECTED INTERRUPT LEVELS
        OUT     (P_MI),A        ; SET PROCESSOR MASK REGISTER
;
;  SET THE MONITOR USER STATE CODE, AND INITIALIZE THE MONITOR STACK.
;
        LD      A,USTRESET      ; SET MONITOR USER STATE CODE
        LD      (USTCODE),A

        LD      SP,MSTKBASE     ; SET UP MONITOR STACK
;
;  INITIALIZE THE I/O DEVICES.
;
        CALL    DISPINIT        ; CLEAR DISPLAY SCREEN
        CALL    SCCINIT         ; INITIALIZE SERIAL COMM. CONTROLLER

        .IF     ~DDTMON
	CALL	DSKINIT		; INITIALIZE FLOPPY DISK DRIVER
	CALL	IDEINIT		; INITIALIZE IDE DRIVER
        JP      WASRESET

        .ELSE

        EI
        JP      DDTINIT         ; GO EXECUTE DDT IN PROM

        .ENDC

        .PAGE
;*        MASKABLE INTERRUPT HANDLERS
;
;  THESE ARE LOCATED HERE TO MAKE USE OF THE MEMORY BEFORE
;  THE FIXED INTERRUPT VECTOR.  THEY CAN BE MOVED AS NEEDED
;  DURING FUTURE RE-ORGANIZATIONS.
LEVEL0
        PUSH    AF              ; SAVE USER A AND FLAGS
        LD      A,USTLEV0
        JP      DOTRAP

LEVEL1
        PUSH    AF              ; SAVE USER A AND FLAGS
        LD      A,USTLEV1
        JP      DOTRAP

LEVEL2
        PUSH    AF              ; SAVE USER A AND FLAGS
        LD      A,USTLEV2
        JP      DOTRAP

LEVEL3
        PUSH    AF              ; SAVE USER A AND FLAGS
        LD      A,USTLEV3
        JP      DOTRAP

LEVEL4
        PUSH    AF              ; SAVE USER A AND FLAGS
        LD      A,USTLEV4
        JP      DOTRAP

LEVEL5
        PUSH    AF              ; SAVE USER A AND FLAGS
        LD      A,USTLEV5
        JP      DOTRAP

;  FURTHER LEVELS CONTINUED BELOW

;*        INTERRUPT VECTOR
;
;  THIS TABLE CONTAINS THE STARTING ADDRESS FOR THE
;  INTERRUPT HANDLERS FOR EACH MASKABLE INTERRUPT LEVEL.
;  THIS TABLE IS REFERENCED BY THE PROCESSOR.
;
        .ORG    IVECTOR

        .WORD   LEVEL0
        .WORD   LEVEL1
        .WORD   LEVEL2
        .WORD   LEVEL3
        .WORD   LEVEL4
        .WORD   LEVEL5
        .WORD   LEVEL6
        .WORD   LEVEL7

;  CONTINUATION OF MASKABLE INTERRUPT HANDLERS AFTER
;  THE FIXED INTERRUPT VECTOR TABLE.

LEVEL6
        PUSH    AF              ; SAVE USER A AND FLAGS
        JP      SCCINTR

LEVEL7
        PUSH    AF              ; SAVE USER A AND FLAGS
        LD      A,USTLEV7
        JP      DOTRAP

        .PAGE
;*        DOTRAP - PROCESS TRAP IN USER PROGRAM
;
;         ENTRY - USER AF ON TOP OF STACK.
;                 USER PC BELOW AF ON STACK
;                 ADDRESS OF INTERRUPT ENTRY IN A
;
DOTRAP
        LD      (USTCODE),A     ; USER STATE CODE = RST DESTINATION
;
;  PUT ALL USER REGISTERS (INCLUDING PC) INTO THE PROPER
;  LOCATIONS IN THE MONITOR WORK AREA.
;  SET UP THE MONITOR STACK.
;
MONENT
        LD      A,I             ; GET USER I AND I FLAG
        DI
        LD      (USERI),A       ; SAVE I REGISTER
        LD      A,0             ; ASSUME INTERRUPTS DISABLED
        JP      PO,$10          ; JUMP IF INTERRUPTS DISABLED

        INC     A               ; SET FLAG
$10
        LD      (USERN),A       ; SAVE INTERRUPT ENABLE
        LD      (USERHL),HL     ; SAVE REGISTERS
        LD      (USERBC),BC
        LD      (USERDE),DE
        LD      (USERIX),IX
        LD      (USERIY),IY
        POP     HL              ; GET BACK AF
        LD      (USERAF),HL     ; STORE AWAY
        POP     HL              ; GET BACK USER PC
        LD      (USERPC),HL     ; AND STORE THAT TOO
        LD      (USERSP),SP     ; SAVE ORIGINAL STACK POINTER
        EX      AF              ; GO TO ALTERNATE REGISTER SET
        EXX
        LD      (USERBCAL),BC   ; SAVE ALTERNATE REGISTERS
        LD      (USERDEAL),DE
        LD      (USERHLAL),HL
        PUSH    AF              ; SAVE ALTERNATE AF
        POP     BC
        LD      (USERAFAL),BC

        LD      SP,MSTKBASE     ; SET UP MONITOR STACK
;
;  CLEAR THE KEYBOARD BUFFER, SO THAT MONITOR OR DDT DO NOT PROCESS
;  INPUT INTENDED FOR THE USER PROGRAM.
;
        ;    CALL    KEYINIT         ; CLEAR KEYBOARD BUFFER
;
;  CHECK TO SEE IF THE USER HAS REQUESTED THAT HE BE
;  ALLOWED TO PROCESS ALL TRAPS.  IF SO, GO TO HIS
;  TRAP PROCESSOR.
;
GODDT
        LD      IY,(TRAPADR)    ; GET ADDRESS OF HANDLER ORIGIN

        .IF     ~DDTMON

        LD      A,(IY+0)        ; GET FIRST BYTE OF HANDLER
        CP      TRPCODE         ; SEE IF IT RESEMBLES HANDLER
        JP      NZ,NODDTC       ; JUMP IF HANDLER NOT THERE

        .ENDC

        LD      BC,TRPEND       ; OFFSET OF ENTRY POINT IN HANDLER
        ADD     IY,BC           ; ADD TO HANDLER ORIGIN
        EI                      ; ENABLE INTERRUPTS SO I/O WORKS
        JP      (IY+0)          ; GO TO HANDLER


        .IF     ~DDTMON

NODDTC
        CALL    DISPINIT         ; INITIALIZE THE I/O DRIVERS
        CALL    DSKINIT
        CALL    SCCINIT
        CALL	IDEINIT

        JP      WASTRP          ; GO TO MONITOR DISPLAY SCREEN

        .ENDC

        .PAGE

        .IF     ~DDTMON

;*        MONITOR DISPLAY FRAME
;
;
MONFRAM
        .BYTE   CH_HOME
        .BYTE   CH_EEOS
        GOTOXY  30,0
        .ASCII  "MONITOR "
        .BYTE   VERSION/100H
        .BYTE   VERSION&0FFH
        GOTOXY  0,22
        .ASCII  "ENTER BOOTSTRAP UNIT NUMBER - "

L_MONFRM .EQU    $-MONFRAM       ; LENGTH OF FRAME DATA
        .PAGE
;*        MONITOR COMMAND PROCESSOR
;
;  CHECK THE CPU OPTION SWITCH.  IF SET, CHECK STATUS OF
;  THE DEFAULT DISK UNIT.  IF READY, DO A 'F' COMMAND.
;
WASRESET
	.IF	~IDE_TEST
	LD      BC,DEFUNIT*100H ; LOAD B AND C
	JP      RDBOOT          ; GO READ AND EXECUTE BOOTSTRAP
	.ENDC

;*
;  DISPLAY MONITOR COMMAND FRAME, AND GET COMMAND FROM USER.
;
WASTRP
        LD      HL,MONFRAM      ; DISPLAY COMMAND FRAME
        LD      BC,L_MONFRM
        CALL    DISPTXT
;
;  GET COMMAND FROM OPERATOR.
;
$10
        CALL    KEYPOLL         ; GO PROCESS KEYSTRIKES
        CALL    KEYSTAT
        LD      A,C             ; GET RESULT OF STATUS CHECK
        AND     A
        JR      Z,$10		; LOOP IF NO KEYSTRIKE YET

	.IF	IDE_TEST
        JP	IDETEST		; JUMP TO IDE TEST PROGRAM
        .ELSE
;
;
;  GET THE BOOTSTART UNIT NUMBER FROM OPERATOR TYPE-IN.
;
        CALL    KEYCHAR         ; READ KEYBOARD
        LD      A,C             ; MOVE CHARACTER TO A REGISTER
        SUB     CH_0            ; CONVERT TO BINARY
        LD      B,A             ; MOVE UNIT NUMBER TO B
        JR      RDBOOT
        .ENDC

        .PAGE
;*        RDBOOT   - READ AND EXECUTE BOOTSTRAP
;
;  ENTER HERE WITH UNIT NUMBER IN B, AND BOOT ENTRY CODE IN C.
;
RDBOOT
        PUSH    BC              ; SAVE BOOTSTRAP PARAMETERS

        LD      HL,LOWIMG       ; INITIALIZE REQUEST BLOCK IN RAM
        LD      DE,BOOTRB
        LD      BC,L_DSKRB
        LDIR

        POP     AF              ; RESTORE BOOTSTRAP PARAMETERS
        LD      (BOOTRB),A      ; STORE UNIT NUMBER IN REQUEST BLOCK
        PUSH    AF              ; SAVE PARAMETERS FOR BOOTSTRAP
;
;  READ THE BOOTSTRAP FROM DISK INTO MEMORY.
;
        LD      HL,BOOTRB       ; PERFORM SECTOR READ
        CALL    DSKRD
        AND     A
        JR      NZ,$10		; JUMP ON I/O ERRORS
;
;  SET UP BOOTSTRAP ENTRY PARAMETERS, AND GO TO IT.
;
        POP     BC              ; SETUP B AND C
        LD      HL,LASTRAM      ; LAST AVAILABLE RAM ADDRESS
        LD      SP,LASTRAM      ; SET UP USER STACK POINTER

        EI                      ; ENABLE INTERRUPTS IN USER PROGRAM
        JP      BOOTADR         ; GO EXECUTE BOOTSTRAP



;*
;  I/O ERROR WHILE READING IN BOOTSTRAP.  SAVE THE ERROR CODE IN
;  THE MONITOR WORK AREA FOR POSSIBLE EXAMINATION WITH DDT,
;  AND GO BACK TO THE MONITOR COMMAND ROUTINE.
;
$10
        LD      (USERAF+1),A    ; SAVE ERROR IN USER A
        JP      WASTRP          ; RETURN TO MONITOR COMMAND PROCESSOR

        .ENDC

        .PAGE
        .IF      0              ; ELIMINATE TO SAVE SPACE

;*        MONEXIT - EXIT FROM MONITOR
;
;         ENTRY - USER REGISTER SAVE AREA SET UP AS DESIRED.
;
;         EXIT - USER REGISTERS RESTORED.
;                EXITS TO USER PC.
;
MONEXIT
        LD      BC,(USERAFAL)   ; RESTORE ALTERNATE USER REGISTERS
        PUSH    BC
        POP     AF
        LD      BC,(USERBCAL)
        LD      DE,(USERDEAL)
        LD      HL,(USERHLAL)
        EX      AF              ; GO TO PRIMARY REGISTER SET
        EXX

        LD      SP,(USERSP)     ; RESTORE USER STACK

        LD      HL,(USERPC)     ; GET USER PC
        PUSH    HL              ; PUT ON STACK

        LD      HL,(USERAF)     ; GET A AND FLAGS
        PUSH    HL              ; SAVE ON STACK

        LD      BC,(USERBC)     ; RESTORE OTHER REGISTERS
        LD      DE,(USERDE)
        LD      HL,(USERHL)
        LD      IX,(USERIX)
        LD      IY,(USERIY)

        LD      A,(USERI)       ; GET I REGISTER
        LD      I,A

        LD      A,(USERN)       ; GET INTERRUPT ENABLE FLAG
        BIT     0,A             ; CHECK FLAG
        JR      Z,$10      ; JUMP IF NOT SET
        EI      ENABLE          ; INTERRUPTS

$10
        POP     AF              ; RESTORE A AND FLAGS

        RET                     ; RETURN  TO CALLER

        .ENDC
        .PAGE

        .IF     ~DDTMON

;*        BOOTSTRAP REQUEST BLOCK IMAGE
;
;  WE USE THIS SAME REQUEST BLOCK FOR BOTH FLOPPY AND IDE
;  BOOTS THROUGH SOME MAJOR KLUDGES.  DRV_DSK.TEXT
;  RECOGNIZES IDE DRIVES THROUGH THEIR UNIT NUMBER, AND
;  THE IDE DRIVER IGNORES THE DISK MAPPING CODE, SO IT
;  DOESN'T MATTER WHAT IT IS FOR IDE DRIVES.  THE IDE
;  DRIVER GETS THE BLOCK # FROM THE TWO BYTES USED BY
;  THE FLOPPY DRIVER FOR TRACK AND HEAD ADDRESS.  THEY'RE
;  ZERO FOR THE BOOT SECTOR, SO WE END UP WITH THE
;  DESIRED LBA OF ZERO.
LOWIMG
        .BLOCK  1               ; SPACE FOR UNIT NUMBER
        .BYTE   BOOTTRK         ; TRACK ADDRESS
        .BYTE   BOOTHD          ; HEAD ADDRESS
        .BYTE   BOOTSEC         ; SECTOR ADDRESS
        .BYTE   MAPOPT+V_DRQDDN+RQSIZ5 ; FORMAT CODE
        .BYTE   0               ; FLAGS
        .BYTE   1               ; START OF LOGICAL TRACK
        .BYTE   0               ; RESERVED
        .WORD   BOOTADR         ; ADDRESS OF BOOT IN MEMORY
        .BYTE   1               ; NUMBER OF SECTORS

        .BYTE   0               ; MARK END OF LIST

        .ENDC

        .PAGE
        .INCLUDE DRV_DSP.TEXT
        .PAGE

        .IF     ~DDTMON

        .INCLUDE DRV_DSK.TEXT

        .ENDC

        .PAGE
        .INCLUDE DRV_SCC.TEXT
        .PAGE

        .IF     DDTMON

        .INCLUDE KEY_TBL.TEXT

        .ENDC

        ASSUME  *,LT,ORIGIN+PROMSIZE ; MUST FIT IN ROM
        .ORG    PROMSIZE             ; FORCE ERROR ON OVERFLOW OF PROM
        .END
