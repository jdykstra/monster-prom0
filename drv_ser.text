;*        MODULE SERDRV - SERIAL INTERFACE DEVICE DRIVER
;
;  THIS MODULE IS A GENERALIZED DEVICE DRIVER FOR THE
;  SERIAL INTERFACE.  ITS ENTRY POINTS ARE:
;
;  SERINIT - INITIALIZE HARDWARE AND DRIVER SOFTWARE.  THIS 
;            ENTRY POINT IS INTENDED FOR USE ONLY BY MONITOR.
;
;         ENTRY - NO PARAMETERS
;
;         EXIT - ALL REGISTERS USED
;
;  SERSTAT - GET STATUS OF INTERFACE.  REPORTS CARRIER DETECT AND
;            WHETHER THERE IS A CHARACTER IN THE RECEIVER.
;
;         ENTRY - NO PARAMETERS
;
;         EXIT - IF A REGISTER = E.UNTRDY, NO CARRIER DETECTED.
;                C REGISTER CONTAINS COUNT OF CHARACTERS IN BUFFER.
;                ALL REGISTERS USED
;
;  SERREAD - READ ONE CHARACTER FROM THE SERIAL INTERFACE, WAITING IF 
;           NECESSARY.  SERREAD WILL RETURN WITH AN ERROR CODE IF
;           THE CARRIER DROPS.
;
;         ENTRY - NO PARAMETERS
;
;         EXIT - RECEIVED CHARACTER IN C REGISTER.
;                IF A REGISTER = E.UNTRDY, NO CARRIER DETECTED.
;                IF A REGISTER = E.URDTER, DATA ERROR DETECTED.
;                ALL REGISTERS USED.
;
;  SERWRITE - WRITE ONE CHARACTER TO THE SERIAL INTERFACE, WAITING IF 
;             TRANSMITTER IS ALREADY FULL.  SERWRITE WILL RETURN WITH 
;             AN ERROR CODE IF THE CARRIER DROPS. 
;
;         ENTRY - CHARACTER IN C REGISTER
;
;         EXIT - IF A REGISTER = E.UNTRDY, NO CARRIER DETECTED
;                ALL REGISTERS USED.
;
;  SERCTL - CONTROL SERIAL INTERFACE.  SETS NEW OPERATING MODE, OR
;           SENDS A BREAK OVER THE LINE.
;
;         ENTRY - 8251 MODE BYTE IN B.  IF B = 0, 
;                 SEND BREAK.  COMMAND BYTE IN C. 
;
;         EXIT - ALL REGISTERS USED.
;
;  SERINTR - PROCESS RECEIVER INTERRUPT
;
;         ENTRY - AF SAVED ON STACK
;                 ENTERED VIA A JUMP (NOT A CALL) 
;
;         EXIT - RETURNS DIRECTLY TO INTERRUPTED USER PROGRAM
;
;
        .PAGE
;*        DEFINITIONS
;
;
MAXSCNT .EQU    128              ; BUFFER HOLDS 128 CHARACTERS
SERSTOP .EQU    MAXSCNT*2/3      ; STOP WHEN BUFFER 2/3 FULL
SERSTART .EQU   MAXSCNT*1/3      ; START WHEN BUFFER 1/3 FULL



;*        WORK AREA 
;
;
SERCNT  .EQU    SERWORK         ; COUNT OF BYTES IN BUFFER
SERIN   .EQU    SERCNT+1        ; IN POINTER TO BUFFER
SEROUT  .EQU    SERIN+1         ; OUT POINTER TO BUFFER
SERFLG  .EQU    SEROUT+1        ; NON-ZERO IF HOST HAS BEEN STOPPED

SERBUF  .EQU    SERWORKB        ; BUFFER BUFFER SPACE
        .PAGE
;*        ENTRY POINT SERINIT 
;
;
SERINIT
        XOR     A
        LD      (SERCNT),A      ; INITIALIZE BUFFER COUNT
        LD      (SERIN),A       ; INITIALIZE IN POINTER
        LD      (SEROUT),A      ; INITIALIZE OUT POINTER
        LD      (SERFLG),A      ; INITIALIZE FLAG

        LD      B,SSOSTP1B+SSOCHR8B+SSOBDR12
        LD      C,V_SSOERR+V_SSOREN+V_SSOTEN+V_SSOCTS+V_SSOIEN
        JP      SERCTL1
        .PAGE
;*        SUBROUTINE SERINTR - RECEIVER INTERRUPT HANDLER
;
;         ENTRY - AF ON STACK 
;                 ENTERED VIA A JUMP, NOT A CALL
;
;         EXIT - DIRECTLY BACK TO INTERRUPTED USER PROGRAM
;
SERINTR
        CALL    SERPOLL         ; GO READ THE RECEIVER
        POP     AF              ; RESTORE USER AF 
        EI
        RETI
        .PAGE
;*        ENTRY POINT SERSTAT 
;
;
SERSTAT
        LD      A,(SERCNT)       ; GET BUFFER COUNT
        LD      C,A             ; MOVE TO C

        IN      A,(P_SS)        ; GET INTERFACE STATUS
        BIT     S_SSITRM,A
        JR      Z,NOCAR         ; JUMP IF NO CARRIER

        JR      NOERR
        .PAGE
;*        ENTRY POINT SERWRITE
;
;         ENTRY - CHARACTER IN C REGISTER
;
;         EXIT - IF A REGISTER NON-ZERO, NO CARRIER DETECTED
;                A IS ONLY REGISTER USED
;
SERWRITE

OUTLOOP
        IN      A,(P_SS)        ; GET SERIAL INTERFACE STTATUS
        BIT     S_SSITRM,A
        JR      Z,NOCAR         ; JUMP IF NO CARRIER

        BIT     S_SSITRD,A
        JR      Z,OUTLOOP       ; LOOP UNTIL TRANSMITTER READY

        LD      A,C             ; MOVE CHARACTER TO BE SENT 
        OUT     (P_SD),A        ; SEND CHARACTER TO SERIAL TRANSMITTER

NOERR
        LD      A,E_NOERR       ; RETURN CODE OF NO ERROR
        RET



;*
;  CARRIER HAS DROPPED.  RETURN AN ERROR CODE OF DEVICE NOT READY.
;
NOCAR
        LD      A,E_UNTRDY      ; ERROR CODE
        RET
        .PAGE
;*        ENTRY POINT SERREAD 
;
;         ENTRY - NO PARAMETERS
;
;         EXIT - CHARACTER RETURNED IN C
;                ERROR CODE IN A
;
;  NOTE THAT THIS ROUTINE RUNS WITH INTERRUPTS ENABLED.  THEREFORE, THE CODE
;  HAS BEEN ARRANGED SO AS TO NOT INTERFERE WITH THE INTERRUPT SERVICE
;  ROUTINE.
;
SERREAD
;
;  SEE IF THERE ARE CHARACTERS IN THE BUFFER.
;
        LD      A,(SERCNT)       ; GET BUFFER COUNT
        AND     A
        JR      NZ,SERRD1       ; JUMP IF DATA AVAILABLE
;
;  IF THE BUFFER IS EXHAUSTED, CHECK TO MAKE SURE THE CARRIER IS
;  STILL THERE.  IF SO, LOOP AND WAIT FOR A CHARACTER TO ARRIVE.
;
        IN      A,(P_SS)        ; GET SERIAL INTERFACE STATUS
        BIT     S_SSITRM,A
        JR      Z,NOCAR         ; JUMP IF CARRIER DROPPED

        JR      SERREAD         ; LOOP TO WAIT FOR CHAR



;*
;  THERE IS AT LEAST ONE CHARACTER IN THE BUFFER.  CHECK THE ERROR
;  FLAGS THAT ARE IN THE BUFFER WITH IT, AND RETURN THE CHARACTER
;  TO THE CALLER.
;
SERRD1
        LD      A,(SEROUT)      ; GET THE OUT OFFSET
        LD      L,A             ; MOVE IT TO BOTTOM OF HL
        LD      H,SERBUF/0100H  ; CREATE MEMORY POINTER INTO BUFFER
        LD      C,(HL)          ; GET CHARACTER OUT OF BUFFER
        INC     L               ; ADVANCE OFFSET
        LD      B,(HL)          ; GET ERROR BITS OUT OF BUFFER
        INC     L               ; ADVANCE OFFSET AGAIN
        LD      A,L
        LD      (SEROUT),A      ; STORE UPDATED OFFSET INTO MEMORY
;
;  DECREMENT THE CHARACTER COUNT.  THIS IS DONE AFTER THE BUFFER OFFSET
;  IS ADJUSTED, AND WITH A INDIVISIBLE OPERATION, TO AVOID INTEREFERENCE 
;  WITH THE INTERRUPT SERVICE ROUTINE.
;
        LD      HL,SERCNT       ; ADDRESS OF COUNTER
        DEC     (HL)            ; DECREMENT COUNT
;
;  IF WE HAVE STOPPED THE HOST, AND THE BUFFER IS NOW LESS THAN 1/3 FULL,
;  START UP THE HOST.
;
        LD      A,(SERFLG)      ; GET FLAGS
        AND     A               ; SEE IF NON-ZERO
        JR      Z,$20           ; JUMP IF NOT STOPPED
        
        LD      A,(HL)          ; GET CURRENT BUFFER COUNT
        CP      SERSTART
        JR      NC,$20          ; JUMP IF MORE THAN 1/3 FULL
        
        PUSH    BC              ; SAVE READ CHARACTER AND ERROR BITS
        LD      C,CH_DC1        ; SEND DC1 TO RESTART THE HOST
        CALL    SERWRITE
        POP     BC              ; GET BACK READ CHARACTER AND ERROR BITS
        
        XOR     A               ; CLEAR THE STOPPED FLAG
        LD      (SERFLG),A
;
;  GET BACK THE DATA CHARACTER, AND CHECK THE STATUS OF THE 
;  CHARACTER.
;
$20
        LD      A,B             ; GET STATUS CODE
        AND     V_SSIFRM+V_SSIOVR+V_SSIPAR
        JP      Z,NOERR         ; JUMP IF NO ERROR

        LD      A,E_URDTER      ; ERROR CODE
        RET
        .PAGE
;*        SUBROUTINE SERPOLL - POLL SERIAL INTERFACE
;
;         ENTRY - NO PARAMETERS
;
;         EXIT - AF USED
;
SERPOLL
        IN      A,(P_SS)        ; GET SERIAL INTERFACE STATUS
        BIT     S_SSIRFL,A
        RET     Z               ; RETURN IF RECEIVER NOT FULL
;
;  MAKE SURE THAT THERE IS ROOM IN THE BUFFER BUFFER FOR THIS
;  CHARACTER.
;
        PUSH    BC              ; SAVE BC AND HL
        PUSH    HL

        LD      A,(SERCNT)       ; GET BUFFER BYTE COUNT
        CP      MAXSCNT         ; COMPARE TO MAXIMUM BUFFER COUNT
        JR      NZ,$10          ; JUMP IF THERES ROOM IN THE BUFFER

        IN      A,(P_SD)        ; DISCARD CHARACTER TO CLEAR INTERRUPT
        JR      SEREXIT
        


;
;  PUT CHARACTER AND STATUS BYTE INTO THE BUFFER.
;
$10
        LD      A,(SERIN)       ; GET BUFFER OFFSET
        LD      L,A             ; PUT INTO BOTTOM OF HL
        LD      H,SERBUF/0100H  ; CREATE POINTER INTO BUFFER
        
        IN      A,(P_SD)        ; GET DATA CHARACTER
        LD      (HL),A          ; PUT INTO BUFFER
        INC     L               ; BUMP BUFFER POINTER
        IN      A,(P_SS)        ; GET INTERFACE STATUS
        LD      (HL),A          ; PUT INTO BUFFER
        LD      B,A             ; SAVE STATUS IN B
        INC     L               ; BUMP POINTER AGAIN
        LD      A,L             ; STORE OFFSET BACK INTO MEMORY
        LD      (SERIN),A
;
;  BUMP THE BUFFER CONTENTS COUNTER.
;
        LD      HL,SERCNT       ; BUMP CONTENTS POINTER
        INC     (HL)
;
;  IF ONE OR MORE ERRORS WERE DETECTED ON THIS CHARACTER, RESET
;  THE ERROR FLAG IN THE SERIAL INTERFACE.
;
        LD      A,B             ; GET STATUS FROM LAST CHARACTER
        AND     V_SSIFRM+V_SSIOVR+V_SSIPAR
        JR      Z,$30           ; JUMP IF NO ERRROR DETECTED

        CALL    TRANSEMP        ; WAIT UNTIL TRANSMITTER IS EMPTY

        LD      A,V_SSOREN+V_SSOCTS+V_SSOTEN+V_SSOERR
        OUT     (P_SS),A
;
;  SEE IF BUFFER IS MORE THAN 2/3 FULL.  IF SO, SEND A DC3 TO STOP THE
;  HOST FROM TRANSMITTING (ASSUMING THAT WE HAVEN-T ALREADY DONE SO).
;
$30
        LD      A,(SERCNT)      ; GET COUNT OF CHARS IN BUFFER
        CP      SERSTOP         ; COMPARE TO THRESHOLD
        JR      C,SEREXIT       ; JUMP IF PLENTY OF ROOM
        
        LD      HL,SERFLG       ; ADDRESS OF FLAG
        LD      A,(HL)          ; CHECK TO MAKE SURE DC3 NOT ALREADY SENT
        AND     A
        JR      NZ,SEREXIT      ; JUMP IF WE-VE ALREADY DONE IT
        
        LD      C,CH_DC3           ; STOP THE HOST
        CALL    SERWRITE
        
        INC     (HL)            ; MARK THAT WEVE SEND A DC3
;
;  EXIT FROM THE POLL ROUTINE.
;
SEREXIT
        POP     HL              ; RESTORE HL, BC
        POP     BC

        RET
        .PAGE
;*        ENTRY POINT SERCTL
;
;
SERCTL
        LD      A,B             ; MOVE DATA TO A REGISTER
        AND     A               ; CHECK A FOR ZERO
        JR      NZ,CNGCTL       ; JUMP IF NEW CONTROL WORD
;
;  SEND OUT A BREAK OVER THE SERIAL INTERFACE.
;
        CALL    TRANSEMP        ; WAIT UNTIL TRANSMITTER EMPTY

        LD      A,V_SSOBRK+V_SSOREN+V_SSOCTS+V_SSOTEN
        OUT     (P_SS),A

        LD      HL,8FFFH
        LD      BC,-1

BRKDLY
        ADD     HL,BC
        JR      C,BRKDLY        ; WAIT APPROXIMATELY 1/4 SECOND

        LD      A,V_SSOREN+V_SSOCTS+V_SSOTEN+V_SSOERR
        OUT     (P_SS),A

        JP      NOERR



;*
;  CHANGE THE SERIAL INTERFACE MODE.
;
CNGCTL
        LD      A,V_SSORST
        OUT     (P_SS),A        ; RESET INTERFACE 
;
;  DELAY A SHORT TIME BEFORE ISSUING THE OTHER COMMANDS TO THE 8251.
;  THIS ALLOWS THE DEVICE TO PERFORM ITS INITIALIZATION SEQUENCE.
;
SERCTL1
        LD      A,B             ; MOVE THE MODE WORD TO A

        LD      B,0FFH          ; DELAY CONSTANT
INITLP
        DJNZ    INITLP          ; DELAY A WHILE

        OUT     (P_SS),A        ; OUTPUT NEW MODE WORD

        LD      A,C             ; GET NEW COMMAND 
        OR      V_SSOIEN        ; MAKE SURE INTERRUPTS ARE ENABLED
        OUT     (P_SS),A

        JP      NOERR
        .PAGE
;*        TRANSEMP - WAIT UNTIL TRANSMITTER EMPTY OR NO CARRIER
;
;         ENTRY - NO PARAMETERS
;
;         EXIT - A CONTAINS INTERFACE STATUS
;
TRANSEMP
        IN      A,(P_SS)        ; GET SERIAL INTERFACE STATUS
        BIT     S_SSITDN,A
        RET     NZ              ; RETURN IF TRANSMITTER DONE

        BIT     S_SSITRM,A
        JR      NZ,TRANSEMP     ; LOOP IF CARRIER STILL THERE

        RET

